## Indralink

Indralink is a minimal stack language that takes inspiration from Forth, while using a VM and supporting streamlined data types.

Any aspect of Indralink is provisional and subject to change.

Target is to use Indralink for embedded scripting (e.g. with Muwerk)

## Preliminary language description

Indralink is primarily a stack language: functions operate on values that are pushed on the stack:

```indralink
1 2 +
```

### Functions

gives `3`. Functions can be defined with `: <func-name> ... ;` syntax similar to Forth. Comments are
anything between `( ... )` and (in files only) from `\` up to line-end, as in Forth.

In repl, functions are on one line, in files (`load`, `save` e.b.), function can be formatted arbitrarily.

```indralink
: plus2 (INT n -- n+2) 2 + ;    \ The comment in brackets () uses Forth style: an INT argument n is expected on stack, a result n+2 is put on stack.
```
then
```indralink
1 plus2 print  \ put 1 on stack, call function plus2 and print the result that is on the stack.
```

gives `3`.

### Variables

Local and global variables can be used, global variables start with `$`.

```
1 >a   \ store 1 into local variable a. a is only valid during execution of the current context, e.g. this works:
1 >a a 1 + print
```

Prints `2`.

```
1 >a
a print
```

Does not work, in the second expression, a is no longer known. Use globals for that:

```
3 >$a
a print
$a print
```

Both work, the second line looks for a local var `a`, if there is none, a global var `$a` is searched and found.

### Data-types

Known data-types are INT, FLOAT, BOOL, STRING, INT_ARRAY, FLOAT_ARRAY, STRING_ARRAY, BOOL_ARRAY

```
3.14 >$a  \ defines global float
"Hello, world" >$s  \ global string
true >$b  \ global bool
33 >$i \ global int
```

Global vars can be listes with `listvars`

#### Arrays

Arrays must be of a single type, containing BOOL, INT, FLOAT, or STRING. They cannot be nested.

```
[1 2 3] >$a
a print
```

generates a 3-element integer array. It could alternatively be generated by:

```
1 3 range  \ generate int array in steps of 1 from `1` to and including `3`. `3 1 range` create the reverse order.
```

```
[true false true] >$b \ bool array
"hello" "" split >$c \ Split takes to arguments, the string to split and a split token, if the split token is empty, the string is split into single chars, and the result is stored into global string array c$. `"1dum2dum4dum" "dum" split` generates `[ "1" "2" "4" ]`. 
```

```
[0 2 4 6] 2 index print
```

gives `4`, zero-based array index 2 has value 4.

```
[0 2 4 6] 2 remove print
```

gives `[0 2 6]`.

`[1 2]` erase gives empty INT array `[]`

Empty arrays can be generated with `[int], [float], [string], [bool]`

### Flow control

#### `if`, `else`, `endif`

`if` expects a BOOL on stack (or an INT, 0=false):

```
1 >a a 2 == if "a=2" else "a!=2" endif print
```

This puts 1 into local var `a`, then compares `a` and `2` for equality, the result (here `false`) is put on stack. `if` checks the stack, sees `false` executes the `else`-branch and puts string "a!=2" on stack. After `endif` `print` prints the last element on stack.

#### `for`, `break`, `next`

The `for` expression iterates over an array on the stack. `break` exists the loop and `next` starts the next iteration:

```
1 10 range for print " " print next
```

generates `1 2 3 4 5 6 7 8 9 10`. `1 10 range` generates an integer-array with 10 elements from 1 to 10. The for loop iterates over the array and prints the current element followed by a `" "`.

```
1 10 range for dup dup 2 % 0 == if print " " print else drop endif 4 == if ">" print break else "<" print endif next
```